# Programming Assignment 7: Agent!

**Late days CANNOT be used on this assignment. Please submit early and often to avoid last minute submission issues!**

**You should work in groups of 3-4 members. (To work in a group of size 2, you must get special permission from the staff.) All submissions will be graded according to the same criteria, regardless of group size.**

In this assignment you will build a customer service agent that can help with movie ticket bookings and other movie-related requests.
The assignment consists of a compulsory part on implementing the collaborative filtering algorithm to recommend movies to the user, and an open-ended part on implementing an LLM agent that can make tool calls, where you are encouraged to be creative and implement interesting functions and tools for the agent to use.

By the end of the assignment, you will submit:

- Code file (`agent.py`) for Part 1
- A text file showing a full transcript of the agent's conversation with the user covering all the features you implemented for Part 1 (transcript_part1.txt)
- Your implementation for Part 2, preferably in the same file (`agent.py`), but if necessary, you can create a new file for it to break things down and upload all the agent-related files
- A text file showing a full transcript of the agent's conversation with the user covering all the features you implemented for Part 2 (transcript_part2.txt)

## Important Setup Note

Although this assignment mostly reuses the environment you set up in PA0, we need one additional package. Recall to activate your PA0 environment you will use:

    conda activate cs124

Please run this command after activating your cs124 environment. We will be using the dspy library to build our agent to make tool calling easier.

    pip install -U dspy

Together API key: make a new python script called "api_keys.py". Inside the script, replace "" with your own API key:

    import os
    TOGETHER_API_KEY = ""
    os.environ["TOGETHER_API_KEY"] = TOGETHER_API_KEY

## Starter Code

We have provided an interface code file for you: `repl.py`. It's a common pattern in software engineering known as the Read-Eval-Print-Loop, REPL. The REPL creates a prompt that gets an input string from the user. Then the REPL passes the input to an agent class that is responsible for doing the work. The response generated by the agent class is then handled again by the REPL, which prints the response and waits for more input.

In the starter code folder, fire up the REPL by issuing the following command:
`python3 repl.py`

You can type your message in the prompt to the movie agent, and hit enter. To exit the REPL, write `:quit`.

All the code that you will need to write for this assignment will be in `agent.py`. We will describe the components that you will need to implement in the next sections.

## Assignment Part 1: Basic Tool-Use Agent (50 points)

### First Tool: Recommend Movies via Collaborative Filtering (25 points)

One of the core functions that your agent has to support is to recommend movies to the user. This is a classic problem in recommender systems, and we will use the collaborative filtering algorithm to solve it. Specifically, you will need to implement the `binarize`, `similarity`, and `recommend_movies` functions in `agent.py`.

We have included the movie ratings matrix in `data/ratings.txt`. You can load it using the `util.load_ratings` function. Moreover, we have populated some synthetic user profiles in `synthetic_users.py` (which you should not modify because our test cases rely on them). The `recommend_movies` function takes in the user name and the number of movies to recommend, and returns a list of movie titles to recommend based on collaborative filtering. You should implement item-item collaborative filtering with cosine similarity with no mean-centering or normalization of scores.

Here is an example of what you should expect to see when you run the REPL:

```python
recommend_movies("Peter", 3)
['Back to the Future (1985)', 'Raiders of the Lost Ark (Indiana Jones and the Raiders of the Lost Ark) (1981)', 'Star Wars: Episode VI - Return of the Jedi (1983)']
```

You should expect your list of movies to match exactly the ones in the example above if you implement the function correctly. And we can see that the result makes sense because Peter is a sci-fi fan based on his profile in `synthetic_users.py`.

### Integrating Tools into an LLM Agent (5 points)

Now that we have built a `recommend_movies` function, we can integrate it into an LLM agent so that it can make tool calls to the `recommend_movies` function. We will use the dspy library to build our agent to make tool calling easier.

We have provided a `MovieTicketAgent` class in `agent.py` that you can use as a starting point. We have also provided a `general_qa` function that you can use to answer general questions about the movie ticket agent.

To add these tools to your agent, you can simply add them to the `tools` list in the `react_agent` variable. Dspy will automatically implement the ReAct framework for you (based on https://arxiv.org/abs/2210.03629) to interleave reasoning and tool calls.

```python
react_agent = dspy.ReAct(
    MovieTicketAgent,
    tools = [
        recommend_movies,
        general_qa,
    ]
)
```

You can then run the REPL script to see your agent in action: `python3 repl.py`.

You should expect to see your agent making tool calls to the `recommend_movies` function and answering general questions about the movie ticket agent. Here is an example of what you should expect to see:

```text
Movie Ticket Agent> Hello! I'm the Movie Ticket Agent. How can I help you today?
> My name is Peter, recommend 3 movies to me.
Movie Ticket Agent>
Prediction(
    trajectory={'thought_0': 'I need to recommend 3 movies to Peter. I will use the recommend_movies tool to generate a list of movie titles for him.', 'tool_name_0': 'recommend_movies', 'tool_args_0': {'user_name': 'Peter', 'k': 3}, 'observation_0': ['Back to the Future (1985)', 'Raiders of the Lost Ark (Indiana Jones and the Raiders of the Lost Ark) (1981)', 'Star Wars: Episode VI - Return of the Jedi (1983)'], 'thought_1': 'I have successfully recommended 3 movies to Peter: "Back to the Future", "Raiders of the Lost Ark", and "Star Wars: Episode VI - Return of the Jedi". Now, I will ask Peter if he would like to book a ticket for any of these movies.', 'tool_name_1': 'finish', 'tool_args_1': {}, 'observation_1': 'Completed.'},
    reasoning='I recommended 3 classic movies to Peter based on his request. The movies are "Back to the Future," "Raiders of the Lost Ark," and "Star Wars: Episode VI - Return of the Jedi." I have completed the recommendation process and am ready to assist him further if he wishes to book a ticket for any of these films.',
    process_result='I have recommended the following 3 movies to you, Peter: "Back to the Future," "Raiders of the Lost Ark," and "Star Wars: Episode VI - Return of the Jedi." Let me know if you would like to book a ticket for any of these!'
)

> give me a plot summary for "Star Wars: Episode VI - Return of the Jedi"
Movie Ticket Agent>
Prediction(
    trajectory={'thought_0': 'The user is asking for a plot summary of "Star Wars: Episode VI - Return of the Jedi." Since this request does not involve booking tickets or any other specific action related to movie tickets, I will use the general question answering tool to provide the plot summary.', 'tool_name_0': 'general_qa', 'tool_args_0': {'user_request': 'give me a plot summary for "Star Wars: Episode VI - Return of the Jedi"'}, 'observation_0': ['"Star Wars: Episode VI - Return of the Jedi" follows the Rebel Alliance\'s final efforts to defeat the Galactic Empire. The film opens with Luke Skywalker, now a Jedi Knight, attempting to rescue Han Solo from the clutches of the crime lord Jabba the Hutt. After a daring rescue, Luke reunites with his friends Leia Organa, Han, and the droids C-3PO and R2-D2.\n\nMeanwhile, the Empire is constructing a new Death Star, even more powerful than the first. The Rebels learn of this and plan an assault to destroy it. Luke confronts Darth Vader, hoping to redeem his father and bring him back to the light side of the Force. The Emperor, aware of Luke\'s potential, seeks to turn him to the dark side.\n\nAs the Rebel fleet engages the Empire in a massive space battle, Luke faces the Emperor and Vader on the Death Star. In a climactic moment, Vader ultimately chooses to save his son, killing the Emperor and sacrificing himself in the process. The Death Star is destroyed, and the Rebels celebrate their victory, marking the fall of the Empire and the restoration of peace to the galaxy. The film concludes with a sense of hope and renewal, as the heroes reflect on their journey and the future ahead.'], 'thought_1': 'I have successfully provided the user with a plot summary for "Star Wars: Episode VI - Return of the Jedi." Since the user\'s request has been fulfilled, I can now mark the task as complete.', 'tool_name_1': 'finish', 'tool_args_1': {}, 'observation_1': 'Completed.'},
    reasoning='The user requested a plot summary for "Star Wars: Episode VI - Return of the Jedi." I utilized the general question answering tool to provide a detailed summary of the film\'s plot, covering key events and character arcs, which successfully addressed the user\'s request.',
    process_result='The plot summary for "Star Wars: Episode VI - Return of the Jedi" has been provided. The film follows the Rebel Alliance\'s final efforts to defeat the Galactic Empire, highlighting Luke Skywalker\'s journey to rescue Han Solo, confront Darth Vader, and ultimately bring balance to the Force.'
)
```

Here we are printing the trajectories including the tool calls and observations. You can see that the agent first recommends 3 movies to the user, and then answers the general question about the plot summary of "Star Wars: Episode VI - Return of the Jedi" by making a tool call to the `general_qa` tool. In your submission, make sure your transcript includes the full trajectories like this too so that we can judge whether your agent made the right tool calls.

### Interfacing with Databases (20 points)

An important part of building a customer service agent is to be able to interface with databases to gather and record information about the user and the movies. As a starting point, implement the `book_ticket` and `file_request` tools in `agent.py` and integrate them into your agent.

We have created a mini movie showtime database in `agent.py` that you can use to gather information about the movies and help with movie booking requests. When your agent booked a new ticket, make sure to update the `ticket_database` and deduct the ticket price from the user's balance. For any requests that can't be handled by your agent, make a human customer support request by calling the `file_request` tool to add the request to the `request_database`. Your should print the databases whenever you make new updates to them.

Here is an example of what you should expect to see when you run the REPL:

```text
user> alright book a ticket for Peter for Star Wars: Episode VI - Return of the Jedi
Movie Ticket Agent>
Prediction(
    trajectory={'thought_0': 'I need to book a ticket for Peter for the movie "Star Wars: Episode VI - Return of the Jedi".', 'tool_name_0': 'book_ticket', 'tool_args_0': {'user_name': 'Peter', 'movie_title': 'Star Wars: Episode VI - Return of the Jedi'}, 'observation_0': 'Ticket booked successfully for Peter for the movie Star Wars: Episode VI - Return of the Jedi. The ticket number is fmbbto. Your new balance is 24.0.', 'thought_1': 'The ticket has been successfully booked for Peter. I should now check his balance to confirm the new amount after the ticket purchase.', 'tool_name_1': 'find_balance', 'tool_args_1': {'user_name': 'Peter'}, 'observation_1': 24.0, 'thought_2': 'The ticket has been booked and the balance confirmed. The task is now complete.', 'tool_name_2': 'finish', 'tool_args_2': {}, 'observation_2': 'Completed.'},
    reasoning='I successfully booked a ticket for Peter for the movie "Star Wars: Episode VI - Return of the Jedi". The booking was confirmed, and I also checked his balance after the purchase, which is now 24.0.',
    process_result='The ticket has been booked successfully for Peter. The ticket number is fmbbto, and his new balance is 24.0.'
)
user> print ticket_database

Printing ticket_database:
{'fmbbto': Ticket(user_name='Peter', movie_title='Star Wars: Episode VI - Return of the Jedi', time=Date(year=2025, month=11, day=15, hour=13, minute=0))}


user> can you give me a discount on Star Wars: Episode VI - Return of the Jedi?
Movie Ticket Agent>
...
process_result='I have filed a request for customer support regarding your discount inquiry. The movie "Star Wars: Episode VI - Return of the Jedi" is scheduled for November 15, 2025, at 1:00 PM. You can book tickets through platforms like Fandango, AMC Theatres, or your local cinema\'s website. Additionally, I recommended some similar movies: \n1. Star Wars: Episode IV - A New Hope\n2. Star Wars: Episode V - The Empire Strikes Back\n3. Guardians of the Galaxy\n\nIf you would like to book a ticket for any of these movies or have any other questions, feel free to ask!'

user> print request_database
Printing request_database:

{'3th6rd': Request(user_request='can you give me a discount on Star Wars: Episode VI - Return of the Jedi?', user_name='')}
```

### Transcript and Submission for Part 1

Once you have finished the above, generate a transcript of the agent's conversation with the user covering the following user questions:

```text
- My name is Peter, recommend 3 movies to me.
- recommend 5 movies to Amy please
- Give me a plot summary for "Lord of the Rings: The Two Towers"
- Book a ticket for Peter for Lord of the Rings: The Two Towers
- print ticket_database
- My name is Peter. Can you give me a discount on Lord of the Rings: The Two Towers?
- print request_database
```

Apart from the above transcript, you are also encouraged to add additional user questions that can showcase the use of all the tools you implemented. Make sure that you save the full trajectories of the agent's responses as we showed above in your transcript. Save the transcript as `transcript_part1.txt`.

## Assignment Part 2: Real-World Extensions (50 points)

So far, our agent is still quite toy -- it relies on some synthetic user profiles and a fake movie database. Now it's your turn to extend your agent to support more functionalities that would make it useful in a real-world scenario.
Your task is to implement functions that could support the following functionalities.
We will outline how you might go about implementing each function, but you are free to implement them in any way you want.
We will grade your implementation based on the interaction transcript that your agent has with the user.

### Function 1: Web Search (25 points)

Often times our LLMs don't know the latest information (say you want to know about a new movie that's coming out soon).
To overcome this, we want to integrate web search (through a search API) so that your agent can browse the latest information. Generally we can break this down into several steps: calling the web search tool, parsing the results, and using the results to answer the user's question.

First, in the cs124 conda environment, you will need to install the following:

```python
pip install google-search-results
```

There are many search APIs out there that are free for low-volume usage. One example is the Bing Search API through [SerpAPI](https://serpapi.com/bing-search-api?gad_source=1&gad_campaignid=22795996758&gbraid=0AAAAADD8kqMYKIj4OU0jh5T2CDRegl0W8&gclid=CjwKCAiAlfvIBhA6EiwAcErpyVhlhSJIBshjm4vojNUuHzVO7x4PzQEA9kT4l5ys2SvhmvcRFnZTERoCxw4QAvD_BwE).
To get an API key, you will need to register a free account, click subscribe, then go to the dashboard here (https://serpapi.com/manage-api-key) to get your API key. After you generate the key, please add the following lines to "api_keys.py", and replace "" with your own SERPAPI key.

```python
SERPAPI_API_KEY = ""
os.environ["SERPAPI_API_KEY"] = SERPAPI_API_KEY
```

Once you have an API key, you can use something like this to call the web search tool:

```python
from serpapi import GoogleSearch

params = {
    "engine": "bing",
    "q": "knives out 2025",
    "api_key": "your_api_key"
}

search = GoogleSearch(params)
results = search.get_dict()
```

You can get the list of links from the results dictionary by:

```python
links = [
    item.get("link")
    for item in results.get("organic_results", [])
    if item.get("link")
]
```

You might want to handle pagination of the results too if the results are too many.

Once you get a link, you can read its content with tools like BeautifulSoup:

```python
from bs4 import BeautifulSoup

def extract_text(html: str) -> str:
    soup = BeautifulSoup(html, "html.parser")

    # Remove scripts/css/ads
    for tag in soup(["script", "style", "noscript"]):
        tag.decompose()

    text = soup.get_text(separator=" ", strip=True)
    return " ".join(text.split())
```

By reading the content of the searched results, the agent should be able to give more accurate and up-to-date information to the user, for example, it should be able to handle a query like "do a web search and then tell me about the upcoming knives out movie in 2025 ".

You will complete and run code in web_search.py for this part of the assignment. We provide most of the implementation, including the WebTools class, which enables the search functionality using the code described above. WebTools will be used in the WebSearchAgent class. Before you run the script, please remember to set the SERPAPI_API_KEY value to your api key. You will finish implementing the following three components:

1. Complete the WebSearchQA class by defining the objective of the agent and defining the input and response (hint: it might be helpful to reference the MovieTicketAgent class from agent.py)
2. Next, you will define self.web_tools (one line)
3. Next, you will define self.tools (one line)
4. Finally, you will finish writing the forward function
5. Lastly, you will write 5 more prompts that can test the agent's web search ability.

To receive full credits, you need to demonstrate that the agent can perform web search to access the latest information.

### Function 2: Memory (25 points)

You might notice that the current agent is stateless: it doesn't remember past interactions with the user and you have to explain who you are at every interaction.
Try to implement a memory system so that your agent can remember past interactions with the user and use that memory to personalize the conversation.
You can assume that within each interaction, the user is the same person.

There are many ways to implement the memory system. For simpliciy, we will briefly outline how you could use an existing agent memory library to integrate it into your Dspy ReAct agent.

We will use a library called [Mem0](https://github.com/mem0ai/mem0). First, install it by running:

```bash
pip install mem0ai
```

Before you run the script, please also make sure that you have together installed as we will be accessing LLMs through the Together AI API:

```bash
pip install together
```

You can initialize the memory system by using:

```python
from mem0 import Memory

# Configure environment
os.environ["OPENAI_API_KEY"] = "your-openai-api-key"

# Initialize Mem0 memory system
config = {
    "llm": {
        "provider": "openai",
        "config": {
            "model": "gpt-4o-mini",
            "temperature": 0.1
        }
    },
    "embedder": {
        "provider": "openai",
        "config": {
            "model": "text-embedding-3-small"
        }
    }
}
```

You can create tools that interact with the memory system by writing a MemoryTools class, which includes functions that store, search, fetch, and update memories. Now, open agent_memory.py. We've provided most of the implementation for you. You will need to make the following adjustment:

1. finish writing the search_memories function. Specifically, define results by searching for the relevant memory. Please read the documentation here (the function chat_with_memories might be helpful): https://github.com/mem0ai/mem0.

Now that we have a MemoryTools class working, you can integrate it with our Dspy ReAct agent by writiing the MemoryReActAgent class. We've provided most of the implementation for you in agent_memory.py. You will need to complete the following parts:

1. write the MemoryQA class by adding a goal for the agent and defining user_input and response.
2. In MemoryReActAgent, finish defining self.tools. For your reference, read through how tools is defined in agent.py and make sure to include all the functions.

Now, the function run_memory_agent (see below) wraps everything together and is a minimal example of how the agent would work. In this function, you will need to:

1. add prompts to "conversations" to demonstrate that the agent has memory

```python
import time
def run_memory_agent_demo():
    """Demonstration of memory-enhanced ReAct agent."""

    # Configure DSPy
    lm = dspy.LM(model='openai/gpt-4o-mini')
    dspy.configure(lm=lm)

    # Initialize memory system
    memory = Memory.from_config(config)

    # Create our agent
    agent = MemoryReActAgent(memory)

    # Sample conversation demonstrating memory capabilities
    print("üß† Memory-Enhanced ReAct Agent Demo")
    print("=" * 50)

    conversations = [
       #TODO
    ]

    for i, user_input in enumerate(conversations, 1):
        print(f"\nüìù User: {user_input}")

        try:
            response = agent(user_input=user_input)
            print(f"ü§ñ Agent: {response.response}")
            time.sleep(1)

        except Exception as e:
            print(f"‚ùå Error: {e}")

# Run the demonstration
if __name__ == "__main__":
    run_memory_agent_demo()
```

This is just a minimal demo to illustrate the memory capabilities of the agent, for more details, you can refer to this tutorial: https://dspy.ai/tutorials/mem0_react_agent/.

### Transcript and Submission for Assignment Part 2

Similar to Part 1, include the above example queries as well as additional user questions that can showcase the use of all the tools you implemented. Save the transcript as `transcript_part2.txt`. You should make sure to showcase that the agent is able to remember past interactions with the user and use that memory to personalize the conversation, and that it can make tool calls to the web search tool and answer questions based on the latest information.

### EXTRA CREDIT QUESTION: Final integration

There are two ways you can receive extra credits for this assignment:

1. Come up with an additional feature besides web search and memory and use dspy to show case the additional feature. Feel free to be creative! We've provided a starter file "extra_credit1.py" for you to get started. Your job is to implement the additional feature and provide transcripts that illustrate the feature. At the top of your transcript, please explain what feature you were trying to implement.
2. Integrating web search and memory back into the movie agent: Now that we've implemented both web_search.py and agent_memory.py, you could piece these features back into the movie agent to perform web search as well as search memories. To do so, you can migrate the functionalities from web_search.py to the MemoryReActAgent. We've provided a started file "extra_credit2.py" for you to get started. Your job is to move existing functions from the three agents you implemented here and integrating them into one single agent by unifying the tools. Like before, you will submit a transcript to demonstrate that the agent has all three features (i.e. can book tickets, has memory, and can do web search)!

Submit your assignment via Gradescope. We expect the following files in your final submission:

    agent.py
    api_keys.py
    web_search.py
    agent_memory.py
    transcript_part1.txt (you will need to create this text file)
    transcript_part2.txt (you will need to create this text file)
    * any auxiliary code files you created for Part 2

**We will use your API key to run the autograder on your submission alone. It is important that you make sure there is at least $0.1 left in your account.** If you would like to work out an alternative accomodation please make a private Ed post.
